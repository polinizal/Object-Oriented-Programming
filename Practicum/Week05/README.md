<h1 align="center">ООП - Практикум - 19.03.2025 - Седмица 05</h1>

## Задача 1 

Да се напише клас `Waffle`, която има
* марка - символен низ
* грамаж
* цена на едро
* цена за краен клиент

Да се опише `Store` за вафли, който има в себе си:
* масив от вафли
* максимален брой вафли
* приходи до момента
* разходи до момента
  
Напишете функции, които да позволяват следните действия:
* Продава се вафла по дадена марка
* Купуват се n вафли от склада на дадена марка
* Показва колко вафли има от дадена марка
* Показва печалбата до момента

## Задача 2

Създайте клас `NumberSeries`, който моделира работата с числова редица. В конструктора на класа ще приемате цяло число - начална стойност на редицата (a_0) и указател към функция на преход, приемаща цяло число и връщаща цяло число (a_i = f(a_i-1)).

Трябва да имате следните функционалности:
* Генериране на i-то число от редицата.
* Проверка дали подадено число е част от редицата.
* Setter-и за нова начална стойност и нова функция на преход.

Генерирането на стойности трябва да бъде оптимизирано откъм скорост:
* За коректна работа с фунцкионалността за генериране на i-то по ред число, трябва да поддържате динамичен масив в класа, в който да пазите досега генерираните стойности.
* Ако числото вече е било генерирано, трябва да го върнете като резултат без да го генерирате повторно.
* Ако числото го няма в масива, генерирайте и добавете към масива всички числа, които липсват до a_i в редицата и върнете генерираната стойност. 
* Ако в масива няма достатъчно място, за да се съхранят новите стойности, преоразмерете го по подходящ начин.
* При set-ване на нова начална стойност или функция на преход, трябва да изтривате динамичния масив и да започвате процеса на запазване отначало.

Помислете как трябва да се handle-не коректно копирането на обекти от вашия клас.

## Задача 3 

Ще реализираме проста система за купуване и продаване на различни продукти.

При работата с тази система е възможно да възникнат различен тип грешки. Ще използваме следния Enum за да връщаме описателно грешките:

```c++
enum class State {
    OK,
    NegativeBalance,
    NegativeQuantity,
    UserFull,
    ProductFull,
    PriceFull,
    UserNotFound,
    ProductNotFound,
    ShortOnMoney,
    NotEnoughItems
};
```

1. Клас, представящ потребител `User`:
    * Член-данни:
        - ```size_t``` id - Индекс на потребителя. Никой потребител няма id = 0.
        - ```char*``` name - Име 
        - ```double``` balance - Парите с които разполага.
    * Класът трябва да има:
      - Конструктор по подразбиране (слагат се default стойности на член-данните като id = 0).
      - Конструктор с параметри.
      - ```State``` updateMoney(double factor); - Добавя factor към парите. ```factor``` може и да е отрицателен. Парите никога обаче не са отрицателни. Ако парите стават отрицателни се връща грешка ```NegativeBalance``` и промяната не се отбелязва.
      - ```bool``` hasMoney(double arg);       - Връща дали потребителя има достатъчно пари.
      - ```size_t``` getID                     - Връща индекса на потребителя

2. Клас, представляващ продукт `Product`:
   * Член-данни:
     - ```char*``` name - Име на продукта.
     - ```size_t``` ownedId - id на притежателя му.
     - ```size_t``` quantity - Колко бройки от този продукт притежаваме
     - ```size_t``` productId - Индекс на продукта. Никой продукт няма индекс 0.
   * Класът трябва да има:
     - Конструктор по подразбиране.
     - Конструктор с параметри
     - ```size_t``` getQuantity - връща колко бройки има.
     - ```State``` updateQuantity(int amount) - променя броя на продуктите. Броя на продуктите никога не е по - малък от 0. Ако след промяната продуктите стават по - малко от 0 се връща грешка NegativeQuantity и промяната не се отбелязва.
     - ```size_t``` getProductID - връща индекса на продукта
     - ```size_t``` getOwnerID - връща индекса на притежателя.

3. Клас, пазещ цените на продуктите `Price`:
   * Член-данни:
     - ```size_t``` productId - Индекс на продуктът.
     - ```double``` price     - Цена
   * Класът трябва да има:
     - Конструктор по подразбиране. Отново слага productId = 0.
     - Конструктор с параметри.
     - ```double``` getPrice - Връща цената.
     - ```size_t``` getId    - Връща productId
     - ```State``` updatePrice(double amount) - Добавя amount към price. Ако price става по - малко от 0 фуннкцията връща ```NegativePrice``` и промяната не се отбелязва. 
       
4. Клас, пазещ информация за потребителите в системата `UsersDatabase`:
   * Член-данни
     - ```user*``` users - Статичен масив пазещ всички потребители
     - ```size_t``` size   - Броя на потребителите до момента
   * Класът трябва да има:
     - Конструктор по подразбиране - създава празна база.
     - ```State``` addUser - Добавя потребител в базата. Всеки потребител в базата има **уникално** id. Ако потребителите стават повече от капацитета се враща ```UserFull```
     - ```bool``` hasEnoughMoney(id, money) - проверява дали потребител с този индекс има достатъчно пари.
     - Други помощни функции (bool existUser...)

5. Клас, пазещ информация за продуктите в системата `ProductsDatabase`:
   * Член-данни
     - ```Product*``` products - масив пазещ всички потребители
     - ```size_t``` size   - Броя на потребителите до момента
   * Класът трябва да има:
     - Конструктор по подразбиране - създава празна база.
     - ```State``` addProduct(name, id, prodID, quantity) - Добавя продукт в базата. Всеки продукт в базата има **уникално** productId. ID-то на потребителя се приема като аргумент. Ако превишим броя на продуктите се връща ProductFull.
     - ```size_t``` itemsOwned(id, productID) - връща колко бройки от даден продукт притежава даден потребител.
     - ```State``` update(id, productID, update) - променя колко бройки притежава даден потребител (в случай че продаде нещо или купи)
     - Други помощни функции (existProduct...)

6. Клас, пазещ информация цените на продуктите `PricesDatabase`:
   * Член-данни
     - ```price*``` prices -масив пазещ всички цена
     - ```size_t``` size   - Броя на цени до момента
   * Класът трябва да има:
     - Конструктор по подразбиране - създава празна база.
     - ```State``` addPrice - Добавя цена в базата. Ако превишим броя на цените се връща PriceFull.
     - ```double``` getPrice(id) - Връща цената на продукт по подадено id.

7. Използвайки тези класове ще реализираме клас `SalesSystem`:
   * Член-данни:
     - ```UsersDatabase``` users - Пази информация за потребителите в системата.
     - ```ProductsDatabase``` products - Пази информация за продуктите в системата.
     - ```PricesDatabase``` prices - Пази информация за цените на продуктите в системата.
   * Класът трябва да поддържа:
     - Конструктор по подразбиране - създава празна система.
     - Функция за добавяне на потребител в базата.
     - Функция за добавяне на продукт в базата. **Няма как да добавим продукт ако той няма собственик. Ако ownerID не се съдържа в users добавянето е неуспешно и се връща UserNotFound.**
     - Функция за добавяне на цена на продукт в базата. Цената няма как да е отрицателна. **Няма смисъл да пазим цени за които няма продукти. Ако при добавяне на цена продукта не съществува добавянето е неуспешно и се връща ProductNotFound.**

И най-важната функция, тази чрез която продаваме:

``` State sell(size_t idFrom, size_t idTo, size_t productID, size_t quantity) ```

При продаването е възможно да се случат няколко грешки:
- Някой от потребителите не съществува. Връща се UserNotFound грешка
- Продукта не съществува. Връща се ProductNotFound грешка.
- Потребителя, който купува да няма пари. Връща се ShortOfMoney грешка.
- Потребителя, който продава да няма толкова неща. Връща се NotEnoughItems грешка

Ако за продукта няма цена цената му се приема за 0.

Парите се въртят по стандартния начин. Потребителя който купува губи цената на продукта * броя на продукта.
Симетрично, този който продава печели същата сума.

В базата данни за продуктите броя на притежаваните от продавача продукти се намаля а броя на притежаваните от купувача продукти се уваличава (ако съществува. Ако не се добавя).
