# Обектно-оринетирано програмиране

## Следване на принципите

- Капсулация - винаги гледаме да избегнем публичните setter-и, когато няма причина директно да променяме стойността на поле, нарушавайки инвариантата на класа (тоест промяната на дадено поле се случва в следствие на изпълнение на друга операция).
- Наследяване - правилната йерархия от класове помага за избягване на дублиране на код, но трябва да се внимава с нея, защото може да доведе до проблеми с поддръжката на кода.
- Полиморфизъм - използването на интерфейси и абстрактни класове стои в основата на ООП - възможността да отделим реализацията от използването. Важно е да можем да разширяваме класовете без да променяме съществуващия код.
- Абстракция - навсякъде гледаме да използваме абстрактни класове и интерфейси, за да не налага използването на конкретни реализации. Това помага за възможността за разширяемост на кода.
- SOLID принципи - всяка единица е достатъчно малка, с единствена отговорност, отворена за разширение, но затворена за промяна, зависеща само и единствено от абстракции, не от конкретни реализации, и не съдържа никакви странични ефекти по същество.

## ООП в контекста на C++

- Езика налага изключително много overhead над ООП дизайна, тъй като предполага грижа за динамичната памет и най-вече същинско копиране на обектите, което предполага и имплементация на големи четворки / шестици, които да се грижат за това.
- Тънкости като виртуален деструктор в полиморфна йерархия и необходимостта от клонираща функция за реализацията на полиморфен контейнер.
- Внимаване за утечки на памет и необходимост от използване на умни указатели, които да се грижат за динамичната памет.
- Константността на методите и референциите/указателите е друга тънкост, за която трябва да се внимава.
- Приятелските функции и класове също имат нужда от внимание, тъй като могат да изкривят ООП дизайна, ако не се използват правилно.
- Паметта, която обектите заемат, е друга важна тема, за която трябва да се внимава, което също губи фокуса на ООП дизайна.
- Концепцията за указатели и референции също е важна и носи своите особености, за които трябва да се внимава, особено при работа с наследени класове и полиморфизъм.